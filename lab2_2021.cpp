/*************************************************************
	Практическое занятие №2. 
	
	Инструкции (условная, выбор, циклы)
	Логические операторы, тернарный (условный) оператор 
	Побитовые операторы.
							
*************************************************************/

#include <iostream>


#define	  stop __asm nop	//с помощью директивы препроцессора задаем макроподстановку
/***************************************************************/
int main()
{
// ********************************************************
	//Задание 1. Условная инструкция if-else.Переключатель switch 

	//Задание 1.1 Напишите фрагмент кода, который переводит код символа, 
	//хранящийся в переменной ch в противоположный регистр.
	//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
	//или нажал другую клавишу, которой символ не соответствует

	//Подсказка: работаем только с символами английского алфавита, для которого в таблице
	// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
	// соответствующей буквы верхнего регистра.
	
	//Обратите внимание, что в кодировочной таблице между буквами верхнего и нижнего регистра 
        //расположены некоторые иные символы
	{
		// Сформируйте значение переменной ch с помощью потока ввода
		char ch;
		std::cout << "Enter latin letter" << std::endl;
		std::cin >> ch;
		if (ch >= 'A' && ch <= 'Z') {
			ch = ch + 0x020;
			std::cout << ch << std::endl;
		}
		else if (ch >= 'a' && ch <= 'z') {
			ch = ch - 0x020;
			std::cout << ch << std::endl;
		}
		else {
			std::cout << "Wrong symbol" << std::endl;
		}
		//... изменили регистр

		// здесь проверили в отладчике значение или вывели "эхо" на экран
		stop
	}
	//Задание 1.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику: 
	//если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
	{
		float x, y;
		std::cout << "Enter x" << std::endl;
		std::cin >> x;
		if (x <= 0) {
			y = 0;
		}
		else if (x >= 1) {
			y = 1;
		}
		else { y = x; }
		std::cout << "y=" << y << std::endl;
	stop
	}
	//Задание 1.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: 
	//в переменной cInput типа char дано значение символа,введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
	{
		int x, y;
		std::cout << "Enter x" << std::endl;
		std::cin >> x;
		char ch;
		std::cout << "Enter symbol" << std::endl;
		std::cin >> ch;
		//сформировали значение
		switch (ch) {
			case 'y': 
				
			case 'Y':
				y = x;
				std::cout << "y=" << y << std::endl;
				break;
			case 'n': 
				y = x * 2;
				std::cout << "y=" << y << std::endl;
				break;
			case 'N':
				y = x * 2;
				std::cout << "y=" << y << std::endl;
				break;
			default: 
				std::cout << "Error" << std::endl;
				break;//switch
		}
		stop
	}
// ********************************************************
	//Задание 2. Логические операторы.
	// В Григорианском календаре (которым мы все пользуемся) високосный год
	// определяется по следующему алгоритму: високосным является каждый четвертый год,
	// но каждый сотый високосным НЕ является, при этом каждый 400-й год все таки 
	// високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
	// 2000 - високосный.
	// Напишите фрагмент кода, такой что:
	// логическая переменная isLeapYear принимает значение true, если год, заданный
	// переменной year - високосный.

	// Примечание: НЕ надо пользоваться инструкциями if-else, switch и тернарным оператором 
	//             НАДО написать логическое выражение в одну строку.
	//(*)если возникнут затруднения при решении задачи, то можно сначала решить ее с помощью if-else,
	// а потом уже выполнить предложенное задание.
	{
		int year = 1823;
		//int year = 1824;
		//int year = 1900;
		//int year = 2000;
		//Вычислили значение 
		bool isLeapYear = (year%4==0) && (year%400==0 || year%100!=0);
		// проверили значение в отладчике
		stop
	}


// *******************************************************
	//Задание 3. Тернарный оператор.  
	//С помощью тернарного оператора найдите максимальное из трех значений

	//(*)если возникнут затруднения при решении задачи, то можно сначала решить ее с помощью if-else,
	// а потом уже выполнить предложенное задание.
	{
	int x, y, z, max;
	std::cout << "Enter x, y and z" << std::endl;
	std::cin >> x >> y >> z;
	max = (x > y && x > z) ? x : (( y > z) ? y : z);
	std::cout << "The greatest is " << max << std::endl;
	stop	
	}

// ********************************************************
	//Задание 4. Циклы.

	//Задание 4.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Задайте границы с помощью потока ввода (или прямо в коде).
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	{
		int min, max, sum=0;
		std::cout << "Enter min and max" << std::endl;
		std::cin >> min >> max;//1) сформировать границы диапазона
		if (min > max) {
			std::cout << "Error" << std::endl;//2) проверить корректность значений
		}
		else {
			for (min; min <= max; min++) {
				sum += min;//3) вычислить сумму
			}
			std::cout << "The sum is " << sum << std::endl;//4) проверить в отладчике значение (или вывести на консоль)
		}
		

		

		
		
	stop
	}


	//Задание 4.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.

	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант.

	{
		int x;
		do {
			std::cout << "Enter number" << std::endl;
			std::cin >> x;
		} while (x<10 || (x%2 != 0));
	stop
	}

	//Задание 4.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7
	{
		int x = 0;
		double sum = 0;
		while (sum <= 1.7) {
			++x;
			sum = sum + 1.0/x;
		}
		std::cout << "x=" << x << std::endl;
		
	stop
	}
// ********************************************************
//Задание 5 Побитовая арифметика (and, or, xor, not), сдвиги.
	//5.1 
	{
	//а)Задайте значение пременной типа char с помощью потока ввода.
	//(для отладки можно задать значение с помощью числового литерала в 2-чном или 16-ричном коде)

	char val, val_mod;
	std::cout << "Enter symbol" << std::endl;
	std::cin >> val;
	//б)	обнулите значение его 6-го бита
	int mask = 1 << 6;
	mask = ~mask;
	val_mod = val & mask;
	stop
			
	//в)	определите значение его 5го бита //
	mask = 1 << 5;
	bool val_mod2 = val & mask;
	stop
		//г)	установите в 1 бит на 4-ой позиции
	mask = 1 << 4;
	
	val_mod = val | mask;
	stop
	}

	//5.2 
	{
	//Если число кодируется более чем одним байтом, то важно, 
	//в каком порядке байты записываются в памяти компьютера или передаются по линиям связи.			//В архитектуре x86  используется порядок от младшего к старшему (англ. little-endian)
	//Для протоколов TCP/IP стандартным является порядок от старшего к младшему (англ. big-endian)  
	//Задайте значение x, например:

	int x = 0xA1B2C3D4;
	//байты числа в памяти следуют в порядке от младшего к старшему
	//поменяйте местами байты так, чтобы они следовали в памяти в обратном порядке 
	//(от старшего к младшему)
	//Например, если x= 0xA1B2C3D4, то после перестановки получим 0xD4C3B2A1
	int first = static_cast<unsigned int>(x) >> 24;
	int second = static_cast<unsigned int>(x) >> 8;
	int mask = 0x0000FF00;
	second = second & mask;
	int third = x << 8;
	mask = 0x00FF0000;
	third = third & mask;
	int fourth = x << 24;
	mask = 0xFF000000;
	fourth = fourth & mask;
	int res = first | second | third | fourth;
	stop
	}
// ********************************************************
	//Задание 6 Побитовая арифметика (and, or, xor, not), сдвиги.
	//6.1 
	{
		int y;//Задайте значение y, например, с помощью потока ввода 
		std::cin >> y;//или с помощью числового литерала в двоичном или 16-ричном виде

		//С помощью побитовых операторов и операторов сдвига:
		//выведите значение "y"  на консоль в двоичном виде, например:
		// если y==9, то 
		// 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)
		unsigned int mask = 0x80000000;
		while (mask != 0) {
			bool sign = y & mask;
			std::cout << sign << ' ';
			mask = mask >> 1;
		}
	}
	//6.2
	{
		//Выведите значение "y"  на консоль в двоичном виде, 
		//пропустив незначащие нули, например:
		// если y==9, то результат  1 0 0 1
		int y;
		std::cin >> y;
		unsigned int mask = 0x80000000;
		bool sign = 0;
		do {
			sign = y & mask;
			mask = mask >> 1;
			if (sign == 1) { std::cout << sign << ' '; }
		} while (sign == false);
		while (mask != 0) {
			sign = y & mask;
			std::cout << sign << ' ';
			mask = mask >> 1;
		}

	} 
	//6.3 (*)
	{
		//Дана целая переменная
		int y;//Задайте значение y, например, с помощью потока ввода
		std::cin >> y;
		unsigned int mask = 0x80000000;
		int rez = 0;
		while (mask != 0) {
			bool sign = y & mask;
			if (sign == 0) {
				mask = mask >> 1;
			}
			else {
				rez = rez | sign;
				mask = mask >> 1;
				if (mask != 0) { rez = rez << 1; }
				
			}
		}
		mask = 0x80000000;
		while (mask != 0) {
			bool sign = rez & mask;
			std::cout << sign << ' ';
			mask = mask >> 1;
		}
	//"Сдвиньте" все единицы в этой переменной вправо, например:
	//было:   0100 1111 0000 0000 0110 1111 0000 0010
	//стало:  0000 0000 0000 0000 0000 1111 1111 1111
	//Выведите на консоль полученное значение в двоичном виде ( можно на печати не разделять тетрады пробелом)

		stop
	}
	
	//6.4 (*)
	//Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
		
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не сасают" 
	{
		short sNum = 0x8008;
		short sRes;
		sRes = sNum ^ 0x8018;
		//0x7ff7 sRes = ~sNum;

		//0x8ff8 sRes = sNum | 0x0ff0;

		//0x0008 sRes = sNum & 0x0008;

		//0x7f08 sRes = ~sNum ^ 0x00ff;

		//0xf001 sRes = sNum ^ 0x7009;

		//0x0010 sRes = sNum ^ 0x8018;

		stop
	}


	return 0;//код завершения приложения
}	// Конец функции main()
